# Akka

## スケール

リソースの増加に対して、線形（O(N)）ないしそれより緩やか（例えば、O(log N)）な速度であることが理想

### 伝統的なアプローチとの違い

| 目的 | 伝統的アプローチ | アクターアプローチ |
| -- | -- | -- |
| アプリ再起動、クラッシュしても処理中データ保持 | 逐次DBにセーブ | 状態はインメモリー(変更はログから復元) |
| インタラクティブ | 定期的にポーリング | イベント発生時にプッシュ |
| サービス分離 | メッセージキュー追加 | アクター自体が非同期 |
| 1サービスクラッシュの全体波及阻止 | 全例外捕捉 | アクターの仕組み上、クラッシュが他サービスに影響しない |

## Akkaとは

- アクタープログラミングモデル

- 設定やメッセージブローカーを設置するオーバーヘッドのないメッセージキューと似ている

- メッセージを送られない限りは何もしない

- メッセージはシンプルなデータ構造で、作成後は変更できない（＝イミュータブル）

- １通ずつメッセージを受信し、その都度なんらかの振る舞いを実行する

- アクターからアクターにメッセージを送れる

- すべてを非同期で実行

## リアクティブ宣言

- ブロッキングI/Oは並列化を制限するため、ノンブロッキングI/Oが望ましい

- 同期的な対話は並列化を制限するため、非同期な対話が望ましい

- ポーリングはリソース消費を削減する機会を減らしてしまうため、イベント駆動のスタイルが望ましい

- もし、あるノードが他のノードを道連れでダウンさせる可能性があると、資源の無駄遣いになる。そのため、作業をすべて失わないように、エラーを隔離する必要がある（回復力）

- システムには弾力性が必要になる。需要が小さければリソースを減らし、大きければリソースを増やす。
