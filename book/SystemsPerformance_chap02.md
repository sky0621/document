# 詳解システム・パフォーマンス

## chap02_メソドロジー

「データを手に入れる前に理論化するのは大きな間違いだ。そうすると、無意識のうちに事実に理論を合わせていくのではなく、自然と理論に事実を合わせていこうとし始める。」（アーサー・コナン・ドイル）

### 基礎用語

- IOPS ... 1秒あたりのI/Oオペレーション。ディスクI/Oの場合は１秒あたりのデータの読み書きの”回数”。

- スループット ... 通信の場合、データ転送速度（１秒あたりのバイト数等）。DBの場合、１秒あたりのオペレーション数ないしトランザクション数。

- 応答時間（response time） ... オペレーション完了までの時間。サービス処理時間、結果転送時間すべて含む。

- レイテンシー（latency） ... 文脈により応答時間とイコール。その他、オペレーションがサービス提供を待った時間にも使う。

- 使用率（utilization） ... リソース（ないしサービス）がどれだけビジーか。ストレージ提供リソースの場合、消費された容量。

- 飽和（saturation） ... リソースがキューイングした作業のうち、サービスを提供できていないものの割合。

- ボトルネック ... システムパフォーマンスに限界を与えているリソース。

- ワークロード（workload） ... システムに対する入力ないし負荷。DBの場合、クエリとクライアントから送られたコマンドで構成される。

- キャッシュ（cache） ... 限定された量のデータを重複して格納したりバッファリングしたりすることができる高速記憶領域。

### モデル

テスト対象システム＝SUT（System Under Test）

### コンセプト

応答時間＝接続遅延（レイテンシー）＋データ転送時間

#### レイテンシー

- 名前解決（DNS）遅延

- TCP接続（初期化（TCPハンドシェイク））遅延

- TCPデータ転送時間

#### トレードオフ

多くのプロジェクトでは、「時間内」と「低コスト」を優先し、「パフォーマンス」は後回しにする。

パフォーマンスチューニングの代表的なトレードオフは「CPU」か「メモリ」か。

※”キャッシュ”使用すると「CPU↓」「メモリ↑」

#### チューニング

仕事が実行される場所からもっとも近いところで行うと効果的　＝　アプリケーション自体のチューニングがもっとも効果的

ボトルネックがアーキテクチャの問題（例：他のノードは余裕があり、１ノードだけビジー）か負荷（全ノードがビジー）かを見極める。

負荷とスループットが線形にならない境界（ニーポイント（knee point））を探索する。

#### パフォーマンス分析の概念

- Known-Knowns：　パフォーマンス指標をチェックすべきとわかっていて、現在の値もわかっているケース。（例：CPU使用率をチェックすべきで、値が平均10%とわかっている）

- Known-Unknowns：　指標をチェックできること、サブシステムが存在することをわかっているが、まだチェックしていないケース。

- Unknowns-Unknowns：　チェックすべき指標がわからず、実際、チェックしていないケース。（例：デバイスからの割り込みでCPUを大きく消費することを知らないため、デバイス割り込みをチェックしていない）

#### 使用率（utilization）

時間ベースの使用率（例：待ち行列理論）・・・サーバーまたはリソースがビジー状態だった時間の平均的な割合（U=B/T）

※U: 使用率、T: 観察を行った期間、B: Tの期間中システムがビジーだった時間の合計

能力ベースの考え方もある。

#### 視点

##### ワークロード分析

アプリケーションのパフォーマンスを解析

開発者が担当

【指標】

もっとも重要なのは、レイテンシ（応答時間）

【手順】

１．問題を明らかにして確認（例：許容可能な閾値を超えるレイテンシを探す）

２．レイテンシの原因を見つける（ドリルダウン分析）

３．改修後にレイテンシが改善されたことを確認する

※出発点はアプリケーション

##### リソース分析

システムリソース　＝　CPU、メモリ、ディスク、ネットワークインターフェース、バス、インターコネクト

システム管理者が担当

【作業内容】

- パフォーマンス問題の調査

- キャパシティプランニング

【指標】

IOPS、スループット、使用率、飽和

【ツール】

vmstat、iostat、mpstat

### メソドロジー

#### 街灯のアンチメソッド

知っているツール、たまたま見つけたメソッドでチューニングすること。ある問題を見つけても決定的な問題を見つけられない。

#### ランダム変更アンチメソッド

どこに問題があるか適当に推測し、その問題が消えるまで適当に変更を加え、つど、計測。

#### 誰か他人のせいにするアンチメソッド

#### アドホックチェックリストメソッド

同じタイプのシステムでの最近の経験や問題から作った場当たり的なチェックリストを使う。

#### 問題の記述

サポートスタッフが問題に最初に対処するために顧客に尋ねる項目

１．パフォーマンスに問題があると思ったのはなぜか？

２．このシステムは、良好なパフォーマンスで動いていたことがあったか？

３．最近の変更は何か？　ソフトウェアか、ハードウェアか、負荷か？

４．その問題は、レイテンシか実行時間で表現できるか？（例：「登録ボタンを押してから画面が変わるまで１分かかる」等）

５．この問題は他の人やアプリケーションに影響を及ぼしているか？　影響があるのは自分だけか？

６．環境はどうなっているのか？　どのソフトウェア、ハードウェアを使っているのか？　バージョン、構成はどうか？

#### 科学的メソッド

「問題」を明示し、原因の「仮設」を立て、掘り下げて「予測」をする。

「検証」を行い、仮設が正しいか結果を「分析」する。

#### 診断サイクル

「仮設」→「インストルメンテーション」→「データ」→「仮設」

#### ツールメソッド

１．利用できるパフォーマンスツールをリストアップする。

２．個々のツールについて、得られる役に立つ指標をリストアップする。

３．個々の指標について、解釈のためのルールをリストアップする。

★ただし、リストにあるツール内から盲目的に選定することになる。

#### USEメソッド

パフォーマンス調査の初期に行うべきメソッド

- 使用率（Utilization）：　インターバルを通じての割合（例：「１個のCPUが90%の使用率で実行されている」）

- 飽和（Saturation）：　待機キューの長さ（例：「CPUは、平均して長さが4のRunキューを持っている」）

- エラー（Errors）：　報告されたエラーの数

【リソースリスト】

CPU（ソケット、コア、仮想CPU）、メインメモリ、ネットワークインターフェース、ストレージデバイス（ディスク）、コントローラ（ストレージ、ネットワーク）、インターコネクト（CPU、メモリ、I/O））のリストアップ

【ソフトウェアリソース】

- ミューテックスのロック

- スレッドプール

- プロセス／スレッドの容量

- ファイル記述子の容量

【指標タイプの解釈方法】

- 使用率：　100%の場合はボトルネックを起こしている兆候。60%以下も問題が起きている可能性あり。

- 飽和：　0以外の場合は問題が起きている可能性あり。待機キューの長さかキュー内での待ち時間で計測。

- エラー：　0以外の場合は要精査。

#### ワークロードの特性の把握

システムに対する入力に注目する。

- 誰（プロセスID、ユーザーID、リモートIPアドレス）が付加をかけているのか？

- なぜ（コードパス、スタックトレース）負荷がかかっているのか？

- 負荷の特徴は何（IOPS、スループット、方向（読み／書き）、ばらつき）か？

- 負荷は時系列的にどのように変化しているか？

#### ドリルダウン分析

「モニタリング」→「特定」→「分析」

#### レイテンシ分析

#### メソッドR

#### イベントトレーシング

#### ベースライン統計

現在のパフォーマンス指標と過去の値を比較すると手がかりが得られる。

#### 静的パフォーマンスチューニング

#### キャッシュチューニング

１．できる限りスタックの高い位置、つまり処理が実行される場所に近い位置でキャッシングし、キャッシュヒットのオーバーヘッドを下げることを目指す。

２．キャッシュが有効にされており、動作していることをチェックする。

３．キャッシュヒット率とキャッシュミス率をチェックする。

４．キャッシュサイズが動的に変わる場合は、現在のサイズをチェックする。

５．ワークロードに合わせてキャッシュをチューニングする。

６．キャッシュに合わせてワークロードをチューニングする。無駄にキャッシュを使う情報を減らし、ターゲットワークロードのために空けておくスペースを広げる。

#### マイクロベンチマーキング

### モデリング

#### スケーラビリティプロファイル

- 線形スケーラビリティ（linear scalability）：　早い段階で他のスケーラビリティパターンになる。

- 競合（contention）：　シリアルコンポーネントの共有が原因。

- コヒーレンス（coherence）：　一部インスタンスへの変更を他インスタンスに派生させるコストがスケーリング効果を上回ることが原因。

- ニーポイント（knee point）：　特定の位置にスケーラビリティに影響する要因がある。競合やコヒーレンスが関連。

- スケーラビリティシーリング（scalability ceiling）：　バスやインターコネクトがスループット上限に達する等、超えられない限界に達したことが原因。

#### 待ち行列理論

L = λW

L：　システム内の平均要求数

λ：　平均到着率

W：　平均サービス時間

### キャパシティプランニング

#### リソースの限界

1. サーバーの役割と処理するリクエストのタイプを明確化（例：WebサーバーはHTTPリクエスト、DBはクエリ）

2. リクエスト毎のシステムリソース消費量を明確化

#### 要素分析

1. すべての要素を最高値に設定してパフォーマンスを試す。

2. 要素をひとつずつ変更してパフォーマンスを試す。

3. 計測にもとづき、要素ごとにパフォーマンスが落ちた割合と節約コストを記録する。

4. 非機能要件を満たす範囲で要素を落としていく。

### 統計

#### パフォーマンスの定量化

観察による定量化改善事例

1. 【観察】アプリケーションに対する要求の処理に 10ms かかる

2. 【観察】そのうち 9ms がディスクI/O

3. 【提案】I/Oをメモリにキャッシュ

4. 【推計される改善】役９倍

※レイテンシは上記に向いている。同期処理を対象とすること。
